"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_thirdweb_dist_esm_utils_bytecode_extractIPFS_js"],{

/***/ "./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js":
/*!*****************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALPHABET: function() { return /* binding */ ALPHABET; }\n/* harmony export */ });\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n//# sourceMappingURL=alphabet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYmFzZTU4L2FscGhhYmV0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvYWxwaGFiZXQuanM/ZTdlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQUxQSEFCRVQgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFscGhhYmV0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js\n"));

/***/ }),

/***/ "./node_modules/thirdweb/dist/esm/utils/base58/encode.js":
/*!***************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/base58/encode.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58Encode: function() { return /* binding */ base58Encode; }\n/* harmony export */ });\n/* harmony import */ var _alphabet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alphabet.js */ \"./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js\");\n\nconst BASE = _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nfunction base58Encode(source) {\n    if (!(source instanceof Uint8Array)) {\n        throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n        return \"\";\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n        let carry = source[pbegin] || 0;\n        // Apply \"b58 = b58 * 256 + ch\".\n        let i = 0;\n        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n            carry += (256 * (b58[it1] || 0)) >>> 0;\n            b58[it1] = (carry % BASE) >>> 0;\n            carry = (carry / BASE) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error(\"Non-zero carry\");\n        }\n        length = i;\n        pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n        it2++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n        str += _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.charAt(b58[it2] || 0);\n    }\n    return str;\n}\n//# sourceMappingURL=encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYmFzZTU4L2VuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUN6QyxhQUFhLGtEQUFRO0FBQ3JCLHNDQUFzQyxrREFBUTtBQUM5QywwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixlQUFlLGtEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvZW5jb2RlLmpzP2UxOTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQUxQSEFCRVQgfSBmcm9tIFwiLi9hbHBoYWJldC5qc1wiO1xuY29uc3QgQkFTRSA9IEFMUEhBQkVULmxlbmd0aDtcbmNvbnN0IExFQURFUiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gQUxQSEFCRVQuY2hhckF0KDApKSgpO1xuY29uc3QgaUZBQ1RPUiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpKSgpOyAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBpbnRvIGEgYmFzZTU4IHN0cmluZy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgVWludDhBcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgc291cmNlIGlzIG5vdCBhIFVpbnQ4QXJyYXkuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYSBub24temVybyBjYXJyeSBkdXJpbmcgdGhlIGVuY29kaW5nIHByb2Nlc3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGJhc2U1OEVuY29kZSB9IGZyb20gXCJ0aGlyZHdlYi91dGlscztcbiAqIGNvbnN0IHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KFswLCAxLCAyLCAzLCA0LCA1XSk7XG4gKiBjb25zdCBlbmNvZGVkID0gYmFzZTU4RW5jb2RlKHNvdXJjZSk7XG4gKiBjb25zb2xlLmxvZyhlbmNvZGVkKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZTU4RW5jb2RlKHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIGxldCB6ZXJvZXMgPSAwO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwYmVnaW4gPSAwO1xuICAgIGNvbnN0IHBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgICAgcGJlZ2luKys7XG4gICAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgY29uc3Qgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDA7XG4gICAgY29uc3QgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgICBsZXQgY2FycnkgPSBzb3VyY2VbcGJlZ2luXSB8fCAwO1xuICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDEgIT09IC0xOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgICAgICBjYXJyeSArPSAoMjU2ICogKGI1OFtpdDFdIHx8IDApKSA+Pj4gMDtcbiAgICAgICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDA7XG4gICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gaTtcbiAgICAgICAgcGJlZ2luKys7XG4gICAgfVxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICBsZXQgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICAgIGl0MisrO1xuICAgIH1cbiAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIGxldCBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7XG4gICAgICAgIHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0gfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/thirdweb/dist/esm/utils/base58/encode.js\n"));

/***/ }),

/***/ "./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; }\n/* harmony export */ });\n// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true,\n};\nfunction readFixedString(length) {\n    let result;\n    if (length < 16) {\n        if (result = shortStringInJS(length))\n            return result;\n    }\n    if (length > 64 && decoder)\n        return decoder.decode(src.subarray(position, position += length));\n    const end = position + length;\n    const units = [];\n    result = '';\n    while (position < end) {\n        const byte1 = src[position++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            const byte4 = src[position++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nclass Decoder {\n    constructor() {\n        Object.assign(this, defaultOptions);\n    }\n    decodeKey(key) {\n        return key;\n    }\n    decode(source, end = -1) {\n        srcEnd = end > -1 ? end : source.length;\n        position = 0;\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView =\n                source.dataView ||\n                    (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        }\n        catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) {\n                throw error;\n            }\n            throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n                ? source.constructor.name\n                : typeof source}`);\n        }\n        if (this instanceof Decoder) {\n            currentDecoder = this;\n            packedValues =\n                this.sharedValues &&\n                    (this.pack\n                        ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues)\n                        : this.sharedValues);\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        }\n        else {\n            currentDecoder = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n            packedValues = null;\n        }\n        return checkedRead();\n    }\n}\nfunction checkedRead() {\n    try {\n        const result = read();\n        if (bundledStrings) {\n            if (position >= bundledStrings.postBundlePosition) {\n                const error = new Error(\"Unexpected bundle position\");\n                error.incomplete = true;\n                throw error;\n            }\n            // bundled strings to skip past\n            position = bundledStrings.postBundlePosition;\n            bundledStrings = null;\n        }\n        if (position === srcEnd) {\n            // finished reading this source, cleanup references\n            currentStructures = null;\n            src = null;\n            if (referenceMap) {\n                referenceMap = null;\n            }\n        }\n        else if (position > srcEnd) {\n            // over read\n            const error = new Error(\"Unexpected end of CBOR data\");\n            error.incomplete = true;\n            throw error;\n        }\n        else {\n            throw new Error(\"Data read, but end of buffer not reached\");\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    }\n    catch (error) {\n        clearSource();\n        if (error instanceof RangeError ||\n            error.message.startsWith(\"Unexpected end of buffer\")) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction read() {\n    let token = src[position++];\n    const majorType = token >> 5;\n    token = token & 0x1f;\n    if (token > 0x17) {\n        switch (token) {\n            case 0x18:\n                token = src[position++];\n                break;\n            default:\n                throw new Error(`Unknown token ${token}`);\n        }\n    }\n    switch (majorType) {\n        case 0: // positive int\n            return token;\n        case 1: // negative int\n            return ~token;\n        case 2: // buffer\n            return readBin(token);\n        case 3: // string\n            if (srcStringEnd >= position) {\n                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n            }\n            if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n                // for small blocks, avoiding the overhead of the extract call is helpful\n                const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n                if (string !== null) {\n                    return string;\n                }\n            }\n            return readFixedString(token);\n        case 4: { // array\n            const array = new Array(token);\n            for (let i = 0; i < token; i++) {\n                array[i] = read();\n            }\n            return array;\n        }\n        case 5: { // map\n            const object = {};\n            for (let i = 0; i < token; i++) {\n                object[safeKey(read())] = read();\n            }\n            return object;\n        }\n        default: // negative int\n            if (Number.isNaN(token)) {\n                const error = new Error(\"Unexpected end of CBOR data\");\n                error.incomplete = true;\n                throw error;\n            }\n            throw new Error(`Unknown CBOR token ${token}`);\n    }\n}\nfunction safeKey(key) {\n    // protect against prototype pollution\n    if (typeof key === \"string\") {\n        return key === \"__proto__\" ? \"__proto_\" : key;\n    }\n    if (typeof key !== \"object\") {\n        return key.toString();\n    }\n    // protect against expensive (DoS) string conversions\n    throw new Error(`Invalid property name type ${typeof key}`);\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    const start = position;\n    const bytes = new Array(length);\n    for (let i = 0; i < length; i++) {\n        const byte = src[position++];\n        if ((byte & 0x80) > 0) {\n            position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) {\n                return \"\";\n            }\n            const a = src[position++];\n            if ((a & 0x80) > 1) {\n                position -= 1;\n                return;\n            }\n            return fromCharCode(a);\n        }\n        const a = src[position++];\n        const b = src[position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n            position -= 2;\n            return;\n        }\n        if (length < 3) {\n            return fromCharCode(a, b);\n        }\n        const c = src[position++];\n        if ((c & 0x80) > 0) {\n            position -= 3;\n            return;\n        }\n        return fromCharCode(a, b, c);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n        position -= 4;\n        return;\n    }\n    if (length < 6) {\n        if (length === 4) {\n            return fromCharCode(a, b, c, d);\n        }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n            position -= 5;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }\n    if (length < 8) {\n        const e = src[position++];\n        const f = src[position++];\n        if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n            position -= 6;\n            return;\n        }\n        if (length < 7) {\n            return fromCharCode(a, b, c, d, e, f);\n        }\n        const g = src[position++];\n        if ((g & 0x80) > 0) {\n            position -= 7;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g);\n    }\n    const e = src[position++];\n    const f = src[position++];\n    const g = src[position++];\n    const h = src[position++];\n    if ((e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0) {\n        position -= 8;\n        return;\n    }\n    if (length < 10) {\n        if (length === 8) {\n            return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n        const i = src[position++];\n        if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i);\n    }\n    if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n            position -= 10;\n            return;\n        }\n        if (length < 11) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n            position -= 11;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n    }\n    const i = src[position++];\n    const j = src[position++];\n    const k = src[position++];\n    const l = src[position++];\n    if ((i & 0x80) > 0 ||\n        (j & 0x80) > 0 ||\n        (k & 0x80) > 0 ||\n        (l & 0x80) > 0) {\n        position -= 12;\n        return;\n    }\n    if (length < 14) {\n        if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n        }\n        const m = src[position++];\n        if ((m & 0x80) > 0) {\n            position -= 13;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n    }\n    const m = src[position++];\n    const n = src[position++];\n    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n        position -= 14;\n        return;\n    }\n    if (length < 15) {\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n    }\n    const o = src[position++];\n    if ((o & 0x80) > 0) {\n        position -= 15;\n        return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n    return currentDecoder.copyBuffers\n        ? // specifically use the copying slice (not the node one)\n            Uint8Array.prototype.slice.call(src, position, (position += length))\n        : src.subarray(position, (position += length));\n}\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n    // http://cbor.schmorp.de/generic-object\n    return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n    if (src[position++] !== 0x84) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        if (src.length < position) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n    const newPackedValues = read_(); // packed values\n    if (!newPackedValues || !newPackedValues.length) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        error.incomplete = true;\n        throw error;\n    }\n    packedValues = packedValues\n        ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n        : newPackedValues;\n    packedValues.prefixes = read_();\n    packedValues.suffixes = read_();\n    return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = (read_) => {\n    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n    if (!referenceMap) {\n        referenceMap = new Map();\n        referenceMap.id = 0;\n    }\n    const id = referenceMap.id++;\n    const token = src[position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >> 5 === 4) {\n        target = [];\n    }\n    else {\n        target = {};\n    }\n    const refEntry = { target }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    const targetProperties = read_(); // read the next value as the target object to id\n    if (refEntry.used) {\n        // there is a cycle, so we have to assign properties to original target\n        return Object.assign(target, targetProperties);\n    }\n    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n    return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n    mult10[i] = /* @__PURE__ */ (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nconst decode = defaultDecoder.decode;\n//# sourceMappingURL=cbor-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYnl0ZWNvZGUvY2Jvci1kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGdCQUFnQixTQUFTO0FBQ3pCLG1EQUFtRCxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL2J5dGVjb2RlL2Nib3ItZGVjb2RlLmpzP2I5ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gb3JpZ2luYWwgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc3p5cC9jYm9yLXgvYmxvYi9tYXN0ZXIvZGVjb2RlLmpzXG4vLyBoZWF2aWx5IG1vZGlmaWVkIHRvIHJlbW92ZSBhbGwgbm9uLWVzc2VudGlhbCBjb2RlXG4vLyBUT0RPOiByZS1lbmFibGUgdHlwZXNjcmlwdCBhbmQgcHJvcGVybHkgdHlwZSB0aGlzXG4vLyBAdHMtbm9jaGVjayAtIFRPRE86IHJlLWVuYWJsZSB0eXBlc2NyaXB0IGFuZCBwcm9wZXJseSB0eXBlIHRoaXNcbmxldCBzcmM7XG5sZXQgc3JjRW5kO1xubGV0IHBvc2l0aW9uID0gMDtcbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG5sZXQgc3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xubGV0IHN0cmluZ1Bvc2l0aW9uID0gMDtcbmxldCBjdXJyZW50RGVjb2RlciA9IHt9O1xubGV0IGN1cnJlbnRTdHJ1Y3R1cmVzO1xubGV0IHNyY1N0cmluZztcbmNvbnN0IHNyY1N0cmluZ1N0YXJ0ID0gMDtcbmxldCBzcmNTdHJpbmdFbmQgPSAwO1xubGV0IGJ1bmRsZWRTdHJpbmdzO1xubGV0IHJlZmVyZW5jZU1hcDtcbmNvbnN0IGN1cnJlbnRFeHRlbnNpb25zID0gW107XG5sZXQgcGFja2VkVmFsdWVzO1xubGV0IGRhdGFWaWV3O1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdXNlUmVjb3JkczogZmFsc2UsXG4gICAgbWFwc0FzT2JqZWN0czogdHJ1ZSxcbn07XG5mdW5jdGlvbiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAobGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA+IDY0ICYmIGRlY29kZXIpXG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aCkpO1xuICAgIGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGNvbnN0IHVuaXRzID0gW107XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKHBvc2l0aW9uIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUxID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGJ5dGUxICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIDEgYnl0ZVxuICAgICAgICAgICAgdW5pdHMucHVzaChieXRlMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGJ5dGUxICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIC8vIDIgYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDYpIHwgYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChieXRlMSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICAvLyAzIGJ5dGVzXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Y7XG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Y7XG4gICAgICAgICAgICB1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGJ5dGUxICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIC8vIDQgYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGU0ID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIGxldCB1bml0ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MGMpIHwgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICAgICAgICBpZiAodW5pdCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgIHVuaXQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcbiAgICAgICAgICAgICAgICB1bml0ID0gMHhkYzAwIHwgKHVuaXQgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMucHVzaChieXRlMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG4gICAgICAgICAgICB1bml0cy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuICAgIGRlY29kZUtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgZGVjb2RlKHNvdXJjZSwgZW5kID0gLTEpIHtcbiAgICAgICAgc3JjRW5kID0gZW5kID4gLTEgPyBlbmQgOiBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgIHN0cmluZ1Bvc2l0aW9uID0gMDtcbiAgICAgICAgc3JjU3RyaW5nRW5kID0gMDtcbiAgICAgICAgc3JjU3RyaW5nID0gbnVsbDtcbiAgICAgICAgc3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xuICAgICAgICBidW5kbGVkU3RyaW5ncyA9IG51bGw7XG4gICAgICAgIHNyYyA9IHNvdXJjZTtcbiAgICAgICAgLy8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuICAgICAgICAvLyB0ZWNobmlxdWUgZm9yIGdldHRpbmcgZGF0YSBmcm9tIGEgZGF0YWJhc2Ugd2hlcmUgaXQgY2FuIGJlIGNvcGllZCBpbnRvIGFuIGV4aXN0aW5nIGJ1ZmZlciBpbnN0ZWFkIG9mIGNyZWF0aW5nXG4gICAgICAgIC8vIG5ldyBvbmVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhVmlldyA9XG4gICAgICAgICAgICAgICAgc291cmNlLmRhdGFWaWV3IHx8XG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2UuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBkb2Vzbid0IGhhdmUgYSBidWZmZXIsIG1heWJlIGl0IGlzIHRoZSB3cm9uZyB0eXBlIG9mIG9iamVjdFxuICAgICAgICAgICAgc3JjID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBtdXN0IGJlIGEgVWludDhBcnJheSBvciBCdWZmZXIgYnV0IHdhcyBhICR7c291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc291cmNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGVjb2Rlcikge1xuICAgICAgICAgICAgY3VycmVudERlY29kZXIgPSB0aGlzO1xuICAgICAgICAgICAgcGFja2VkVmFsdWVzID1cbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZFZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBBcnJheSh0aGlzLm1heFByaXZhdGVQYWNrZWRWYWx1ZXMgfHwgMTYpLmNvbmNhdCh0aGlzLnNoYXJlZFZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5zaGFyZWRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnREZWNvZGVyID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFja2VkVmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tlZFJlYWQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja2VkUmVhZCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkKCk7XG4gICAgICAgIGlmIChidW5kbGVkU3RyaW5ncykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiVW5leHBlY3RlZCBidW5kbGUgcG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidW5kbGVkIHN0cmluZ3MgdG8gc2tpcCBwYXN0XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGJ1bmRsZWRTdHJpbmdzLnBvc3RCdW5kbGVQb3NpdGlvbjtcbiAgICAgICAgICAgIGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09IHNyY0VuZCkge1xuICAgICAgICAgICAgLy8gZmluaXNoZWQgcmVhZGluZyB0aGlzIHNvdXJjZSwgY2xlYW51cCByZWZlcmVuY2VzXG4gICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlcyA9IG51bGw7XG4gICAgICAgICAgICBzcmMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU1hcCkge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZU1hcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPiBzcmNFbmQpIHtcbiAgICAgICAgICAgIC8vIG92ZXIgcmVhZFxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBDQk9SIGRhdGFcIik7XG4gICAgICAgICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIG1vcmUgdG8gcmVhZCwgYnV0IHdlIGFyZSByZWFkaW5nIHNlcXVlbnRpYWxseSwgc28gZG9uJ3QgY2xlYXIgc291cmNlIHlldFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2xlYXJTb3VyY2UoKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvciB8fFxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyXCIpKSB7XG4gICAgICAgICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkKCkge1xuICAgIGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBtYWpvclR5cGUgPSB0b2tlbiA+PiA1O1xuICAgIHRva2VuID0gdG9rZW4gJiAweDFmO1xuICAgIGlmICh0b2tlbiA+IDB4MTcpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSAweDE4OlxuICAgICAgICAgICAgICAgIHRva2VuID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdG9rZW4gJHt0b2tlbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG1ham9yVHlwZSkge1xuICAgICAgICBjYXNlIDA6IC8vIHBvc2l0aXZlIGludFxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICBjYXNlIDE6IC8vIG5lZ2F0aXZlIGludFxuICAgICAgICAgICAgcmV0dXJuIH50b2tlbjtcbiAgICAgICAgY2FzZSAyOiAvLyBidWZmZXJcbiAgICAgICAgICAgIHJldHVybiByZWFkQmluKHRva2VuKTtcbiAgICAgICAgY2FzZSAzOiAvLyBzdHJpbmdcbiAgICAgICAgICAgIGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB0b2tlbikgLSBzcmNTdHJpbmdTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjU3RyaW5nRW5kID09PSAwICYmIHNyY0VuZCA8IDE0MCAmJiB0b2tlbiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIHNtYWxsIGJsb2NrcywgYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSBleHRyYWN0IGNhbGwgaXMgaGVscGZ1bFxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHRva2VuIDwgMTYgPyBzaG9ydFN0cmluZ0luSlModG9rZW4pIDogbG9uZ1N0cmluZ0luSlModG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkU3RyaW5nKHRva2VuKTtcbiAgICAgICAgY2FzZSA0OiB7IC8vIGFycmF5XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDU6IHsgLy8gbWFwXG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG9iamVjdFtzYWZlS2V5KHJlYWQoKSldID0gcmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBDQk9SIGRhdGFcIik7XG4gICAgICAgICAgICAgICAgZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQ0JPUiB0b2tlbiAke3Rva2VufWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhZmVLZXkoa2V5KSB7XG4gICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ga2V5ID09PSBcIl9fcHJvdG9fX1wiID8gXCJfX3Byb3RvX1wiIDoga2V5O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIHByb3RlY3QgYWdhaW5zdCBleHBlbnNpdmUgKERvUykgc3RyaW5nIGNvbnZlcnNpb25zXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByb3BlcnR5IG5hbWUgdHlwZSAke3R5cGVvZiBrZXl9YCk7XG59XG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChieXRlICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzW2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoIDwgNCkge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgICAgIGlmICgoYSAmIDB4ODApID4gMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBjb25zdCBiID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGEgJiAweDgwKSA+IDAgfHwgKGIgJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChjICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAzO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYyk7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgYiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBjID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGQgPSBzcmNbcG9zaXRpb24rK107XG4gICAgaWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwIHx8IChjICYgMHg4MCkgPiAwIHx8IChkICYgMHg4MCkgPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IDQ7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDYpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGUgJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDgpIHtcbiAgICAgICAgY29uc3QgZSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgY29uc3QgZiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSA2O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCA3KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGcgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoZyAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gNztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcpO1xuICAgIH1cbiAgICBjb25zdCBlID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGYgPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgZyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBoID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGlmICgoZSAmIDB4ODApID4gMCB8fFxuICAgICAgICAoZiAmIDB4ODApID4gMCB8fFxuICAgICAgICAoZyAmIDB4ODApID4gMCB8fFxuICAgICAgICAoaCAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSA4O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxMCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoaSAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gOTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgY29uc3QgaSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgY29uc3QgaiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChpICYgMHg4MCkgPiAwIHx8IChqICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAxMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgayA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChrICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAxMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGspO1xuICAgIH1cbiAgICBjb25zdCBpID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGogPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgayA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBsID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGlmICgoaSAmIDB4ODApID4gMCB8fFxuICAgICAgICAoaiAmIDB4ODApID4gMCB8fFxuICAgICAgICAoayAmIDB4ODApID4gMCB8fFxuICAgICAgICAobCAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSAxMjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTQpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChtICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAxMztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0pO1xuICAgIH1cbiAgICBjb25zdCBtID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IG4gPSBzcmNbcG9zaXRpb24rK107XG4gICAgaWYgKChtICYgMHg4MCkgPiAwIHx8IChuICYgMHg4MCkgPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uIC09IDE0O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCAxNSkge1xuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pO1xuICAgIH1cbiAgICBjb25zdCBvID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGlmICgobyAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSAxNTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8pO1xufVxuZnVuY3Rpb24gcmVhZEJpbihsZW5ndGgpIHtcbiAgICByZXR1cm4gY3VycmVudERlY29kZXIuY29weUJ1ZmZlcnNcbiAgICAgICAgPyAvLyBzcGVjaWZpY2FsbHkgdXNlIHRoZSBjb3B5aW5nIHNsaWNlIChub3QgdGhlIG5vZGUgb25lKVxuICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uLCAocG9zaXRpb24gKz0gbGVuZ3RoKSlcbiAgICAgICAgOiBzcmMuc3ViYXJyYXkocG9zaXRpb24sIChwb3NpdGlvbiArPSBsZW5ndGgpKTtcbn1cbmNvbnN0IGdsYmwgPSB7IEVycm9yLCBSZWdFeHAgfTtcbmN1cnJlbnRFeHRlbnNpb25zWzI3XSA9IChkYXRhKSA9PiB7XG4gICAgLy8gaHR0cDovL2Nib3Iuc2NobW9ycC5kZS9nZW5lcmljLW9iamVjdFxuICAgIHJldHVybiAoZ2xibFtkYXRhWzBdXSB8fCBFcnJvcikoZGF0YVsxXSwgZGF0YVsyXSk7XG59O1xuY29uc3QgcGFja2VkVGFibGUgPSAocmVhZF8pID0+IHtcbiAgICBpZiAoc3JjW3Bvc2l0aW9uKytdICE9PSAweDg0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiUGFja2VkIHZhbHVlcyBzdHJ1Y3R1cmUgbXVzdCBiZSBmb2xsb3dlZCBieSBhIDQgZWxlbWVudCBhcnJheVwiKTtcbiAgICAgICAgaWYgKHNyYy5sZW5ndGggPCBwb3NpdGlvbikge1xuICAgICAgICAgICAgZXJyb3IuaW5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IG5ld1BhY2tlZFZhbHVlcyA9IHJlYWRfKCk7IC8vIHBhY2tlZCB2YWx1ZXNcbiAgICBpZiAoIW5ld1BhY2tlZFZhbHVlcyB8fCAhbmV3UGFja2VkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIlBhY2tlZCB2YWx1ZXMgc3RydWN0dXJlIG11c3QgYmUgZm9sbG93ZWQgYnkgYSA0IGVsZW1lbnQgYXJyYXlcIik7XG4gICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcGFja2VkVmFsdWVzID0gcGFja2VkVmFsdWVzXG4gICAgICAgID8gbmV3UGFja2VkVmFsdWVzLmNvbmNhdChwYWNrZWRWYWx1ZXMuc2xpY2UobmV3UGFja2VkVmFsdWVzLmxlbmd0aCkpXG4gICAgICAgIDogbmV3UGFja2VkVmFsdWVzO1xuICAgIHBhY2tlZFZhbHVlcy5wcmVmaXhlcyA9IHJlYWRfKCk7XG4gICAgcGFja2VkVmFsdWVzLnN1ZmZpeGVzID0gcmVhZF8oKTtcbiAgICByZXR1cm4gcmVhZF8oKTsgLy8gcmVhZCB0aGUgcnVtcFxufTtcbnBhY2tlZFRhYmxlLmhhbmRsZXNSZWFkID0gdHJ1ZTtcbmN1cnJlbnRFeHRlbnNpb25zWzI4XSA9IChyZWFkXykgPT4ge1xuICAgIC8vIHNoYXJlYWJsZSBodHRwOi8vY2Jvci5zY2htb3JwLmRlL3ZhbHVlLXNoYXJpbmcgKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcbiAgICBpZiAoIXJlZmVyZW5jZU1hcCkge1xuICAgICAgICByZWZlcmVuY2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJlZmVyZW5jZU1hcC5pZCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcmVmZXJlbmNlTWFwLmlkKys7XG4gICAgY29uc3QgdG9rZW4gPSBzcmNbcG9zaXRpb25dO1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gVE9ETzogaGFuZGxlIE1hcHMsIFNldHMsIGFuZCBvdGhlciB0eXBlcyB0aGF0IGNhbiBjeWNsZTsgdGhpcyBpcyBjb21wbGljYXRlZCwgYmVjYXVzZSB5b3UgcG90ZW50aWFsbHkgbmVlZCB0byByZWFkXG4gICAgLy8gYWhlYWQgcGFzdCByZWZlcmVuY2VzIHRvIHJlY29yZCBzdHJ1Y3R1cmUgZGVmaW5pdGlvbnNcbiAgICBpZiAodG9rZW4gPj4gNSA9PT0gNCkge1xuICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZWZFbnRyeSA9IHsgdGFyZ2V0IH07IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG4gICAgcmVmZXJlbmNlTWFwLnNldChpZCwgcmVmRW50cnkpO1xuICAgIGNvbnN0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkXygpOyAvLyByZWFkIHRoZSBuZXh0IHZhbHVlIGFzIHRoZSB0YXJnZXQgb2JqZWN0IHRvIGlkXG4gICAgaWYgKHJlZkVudHJ5LnVzZWQpIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBjeWNsZSwgc28gd2UgaGF2ZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmVmRW50cnkudGFyZ2V0ID0gdGFyZ2V0UHJvcGVydGllczsgLy8gdGhlIHBsYWNlaG9sZGVyIHdhc24ndCB1c2VkLCByZXBsYWNlIHdpdGggdGhlIGRlc2VyaWFsaXplZCBvbmVcbiAgICByZXR1cm4gdGFyZ2V0UHJvcGVydGllczsgLy8gbm8gY3ljbGUsIGNhbiBqdXN0IHVzZSB0aGUgcmV0dXJuZWQgcmVhZCBvYmplY3Rcbn07XG5mdW5jdGlvbiBjbGVhclNvdXJjZSgpIHtcbiAgICBzcmMgPSBudWxsO1xuICAgIHJlZmVyZW5jZU1hcCA9IG51bGw7XG4gICAgY3VycmVudFN0cnVjdHVyZXMgPSBudWxsO1xufVxuY29uc3QgbXVsdDEwID0gbmV3IEFycmF5KDE0Nyk7IC8vIHRoaXMgaXMgYSB0YWJsZSBtYXRjaGluZyBiaW5hcnkgZXhwb25lbnRzIHRvIHRoZSBtdWx0aXBsaWVyIHRvIGRldGVybWluZSBzaWduaWZpY2FudCBkaWdpdCByb3VuZGluZ1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIG11bHQxMFtpXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gTnVtYmVyKGAxZSR7TWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKX1gKSkoKTtcbn1cbmNvbnN0IGRlZmF1bHREZWNvZGVyID0gbmV3IERlY29kZXIoKTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkZWZhdWx0RGVjb2Rlci5kZWNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYm9yLWRlY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js\n"));

/***/ }),

/***/ "./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js":
/*!**********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractIPFSUri: function() { return /* binding */ extractIPFSUri; }\n/* harmony export */ });\n/* harmony import */ var _base58_encode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base58/encode.js */ \"./node_modules/thirdweb/dist/esm/utils/base58/encode.js\");\n/* harmony import */ var _encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/to-bytes.js */ \"./node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js\");\n/* harmony import */ var _cbor_decode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cbor-decode.js */ \"./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js\");\n/* harmony import */ var _prefix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prefix.js */ \"./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js\");\n\n\n\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nfunction extractIPFSUri(bytecode) {\n    const numericBytecode = (0,_encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)((0,_prefix_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytecodePrefix)(bytecode));\n    const cborLength = \n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n        // @ts-expect-error - TS doesn't like this, but it's fine\n        numericBytecode[numericBytecode.length - 1];\n    const cborStart = numericBytecode.length - 2 - cborLength;\n    // if the cborStart is invalid, return undefined\n    if (cborStart < 0 || cborStart > numericBytecode.length) {\n        return undefined;\n    }\n    const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n    const cborData = (0,_cbor_decode_js__WEBPACK_IMPORTED_MODULE_2__.decode)(bytecodeBuffer);\n    if (\"ipfs\" in cborData) {\n        return `ipfs://${(0,_base58_encode_js__WEBPACK_IMPORTED_MODULE_3__.base58Encode)(cborData.ipfs)}`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=extractIPFS.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYnl0ZWNvZGUvZXh0cmFjdElQRlMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUQ7QUFDRTtBQUNYO0FBQ1M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsaUVBQVUsQ0FBQyxnRUFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBTTtBQUMzQjtBQUNBLHlCQUF5QiwrREFBWSxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL2J5dGVjb2RlL2V4dHJhY3RJUEZTLmpzPzJlNmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZTU4RW5jb2RlIH0gZnJvbSBcIi4uL2Jhc2U1OC9lbmNvZGUuanNcIjtcbmltcG9ydCB7IGhleFRvQnl0ZXMgfSBmcm9tIFwiLi4vZW5jb2RpbmcvdG8tYnl0ZXMuanNcIjtcbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCIuL2Nib3ItZGVjb2RlLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVCeXRlY29kZVByZWZpeCB9IGZyb20gXCIuL3ByZWZpeC5qc1wiO1xuLyoqXG4gKiBFeHRyYWN0cyB0aGUgSVBGUyBVUkkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZWNvZGUuXG4gKiBAcGFyYW0gYnl0ZWNvZGUgLSBUaGUgYnl0ZWNvZGUgdG8gZXh0cmFjdCB0aGUgSVBGUyBVUkkgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBJUEZTIFVSSSBpZiBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZXh0cmFjdElQRlNVcmkgfSBmcm9tIFwidGhpcmR3ZWIvdXRpbHMvYnl0ZWNvZGUvZXh0cmFjdElQRlNcIjtcbiAqIGNvbnN0IGJ5dGVjb2RlID0gXCIweDM2M2QzZDM3M2QzZDNkMzYzZDMwNTQ1YWY0M2Q4MjgwM2U5MDNkOTE2MDE4NTdmZDViZjNcIjtcbiAqIGNvbnN0IGlwZnNIYXNoID0gZXh0cmFjdElQRlNVcmkoYnl0ZWNvZGUpO1xuICogY29uc29sZS5sb2coaXBmc0hhc2gpO1xuICogYGBgXG4gKiBAdXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJUEZTVXJpKGJ5dGVjb2RlKSB7XG4gICAgY29uc3QgbnVtZXJpY0J5dGVjb2RlID0gaGV4VG9CeXRlcyhlbnN1cmVCeXRlY29kZVByZWZpeChieXRlY29kZSkpO1xuICAgIGNvbnN0IGNib3JMZW5ndGggPSBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVFMgZG9lc24ndCBsaWtlIHRoaXMsIGJ1dCBpdCdzIGZpbmVcbiAgICBudW1lcmljQnl0ZWNvZGVbbnVtZXJpY0J5dGVjb2RlLmxlbmd0aCAtIDJdICogMHgxMDAgK1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVFMgZG9lc24ndCBsaWtlIHRoaXMsIGJ1dCBpdCdzIGZpbmVcbiAgICAgICAgbnVtZXJpY0J5dGVjb2RlW251bWVyaWNCeXRlY29kZS5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBjYm9yU3RhcnQgPSBudW1lcmljQnl0ZWNvZGUubGVuZ3RoIC0gMiAtIGNib3JMZW5ndGg7XG4gICAgLy8gaWYgdGhlIGNib3JTdGFydCBpcyBpbnZhbGlkLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGNib3JTdGFydCA8IDAgfHwgY2JvclN0YXJ0ID4gbnVtZXJpY0J5dGVjb2RlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBieXRlY29kZUJ1ZmZlciA9IG51bWVyaWNCeXRlY29kZS5zbGljZShjYm9yU3RhcnQsIC0yKTtcbiAgICBjb25zdCBjYm9yRGF0YSA9IGRlY29kZShieXRlY29kZUJ1ZmZlcik7XG4gICAgaWYgKFwiaXBmc1wiIGluIGNib3JEYXRhKSB7XG4gICAgICAgIHJldHVybiBgaXBmczovLyR7YmFzZTU4RW5jb2RlKGNib3JEYXRhLmlwZnMpfWA7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0SVBGUy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js\n"));

/***/ }),

/***/ "./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js":
/*!*****************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureBytecodePrefix: function() { return /* binding */ ensureBytecodePrefix; }\n/* harmony export */ });\n/* harmony import */ var _encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/hex.js */ \"./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nfunction ensureBytecodePrefix(bytecode) {\n    if ((0,_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(bytecode, { strict: false })) {\n        return bytecode;\n    }\n    return `0x${bytecode}`;\n}\n//# sourceMappingURL=prefix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYnl0ZWNvZGUvcHJlZml4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsdURBQUssYUFBYSxlQUFlO0FBQ3pDO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9ieXRlY29kZS9wcmVmaXguanM/MDZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0hleCB9IGZyb20gXCIuLi9lbmNvZGluZy9oZXguanNcIjtcbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBnaXZlbiBieXRlY29kZSBoYXMgdGhlIGNvcnJlY3QgcHJlZml4LlxuICogSWYgdGhlIGJ5dGVjb2RlIGFscmVhZHkgc3RhcnRzIHdpdGggXCIweFwiLCBpdCBpcyByZXR1cm5lZCBhcyBpcy5cbiAqIE90aGVyd2lzZSwgdGhlIHByZWZpeCBcIjB4XCIgaXMgYWRkZWQgdG8gdGhlIGJ5dGVjb2RlLlxuICogQHBhcmFtIGJ5dGVjb2RlIC0gVGhlIGJ5dGVjb2RlIHRvIGVuc3VyZSB0aGUgcHJlZml4IGZvci5cbiAqIEByZXR1cm5zIFRoZSBieXRlY29kZSB3aXRoIHRoZSBjb3JyZWN0IHByZWZpeC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW5zdXJlQnl0ZWNvZGVQcmVmaXggfSBmcm9tIFwidGhpcmR3ZWIvdXRpbHMvYnl0ZWNvZGUvcHJlZml4XCI7XG4gKiBjb25zdCBieXRlY29kZSA9IFwiMzYzZDNkMzczZDNkM2QzNjNkMzA1NDVhZjQzZDgyODAzZTkwM2Q5MTYwMTg1N2ZkNWJmM1wiO1xuICogY29uc3QgcHJlZml4ZWRCeXRlY29kZSA9IGVuc3VyZUJ5dGVjb2RlUHJlZml4KGJ5dGVjb2RlKTtcbiAqIGNvbnNvbGUubG9nKHByZWZpeGVkQnl0ZWNvZGUpO1xuICogYGBgXG4gKiBAdXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVjb2RlUHJlZml4KGJ5dGVjb2RlKSB7XG4gICAgaWYgKGlzSGV4KGJ5dGVjb2RlLCB7IHN0cmljdDogZmFsc2UgfSkpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtieXRlY29kZX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js\n"));

/***/ })

}]);